# DataBridge - Integrove Internal Data Migration Platform

You are an expert in TypeScript, React and Next.js 15, PostgreSQL, Drizzle ORM, Zod, Tailwind CSS, and data engineering.

## ğŸš¨ CRITICAL: PRODUCTION-READY CODE ONLY

**THIS IS NOT A PROTOTYPE. THIS IS PRODUCTION.**

- âœ… **Build for large-scale, production-ready environments**
- âœ… **Design for high performance, scalability, and reliability**
- âŒ **NEVER create "simplified", "demo", or "small-scale" versions**
- âŒ **NEVER stub out functionality with placeholders or TODOs**
- âŒ **NEVER skip implementation details "for brevity"**

All code must be:
- Production-grade with proper error handling, logging, and monitoring
- Scalable to handle large datasets (millions of rows)
- Optimized for performance (batch processing, streaming, connection pooling)
- Enterprise-ready with proper transaction management and data integrity
- Fully implemented, not conceptual or simplified

## ğŸš¨ CRITICAL: READ-ONLY FILE PROTECTION

**NEVER DIRECTLY EDIT THE FOLLOWING FILES - THEY ARE READ-ONLY:**

### Database Schema & Migration Files
- `packages/schema/src/schema.ts` - Database schema definitions
- `packages/schema/src/constants.ts` - Schema constants
- `packages/schema/src/relations.ts` - Table relations
- `packages/schema/migrations/*.sql` - Migration SQL files
- `packages/schema/migrations/meta/*.json` - Migration metadata
- `packages/schema/drizzle.config.ts` - Drizzle configuration

### Configuration Files
- `package.json` files - Dependency management (root and workspace)
- `next.config.js` - Next.js configuration
- `tailwind.config.ts` - Tailwind configuration
- `tsconfig.json` - TypeScript configuration
- `yarn.lock` - Dependency lock file
- `postcss.config.js` - PostCSS configuration
- `components.json` - Shadcn/ui configuration

### Environment & Security Files
- `.env*` files - Environment variables and secrets
- `.cursorrules` - AI behavior rules (this file)
- `vercel.json` - Deployment configuration
- `.gitignore` - Git ignore rules

### Critical Behavior Rules:
1. **READ ONLY**: You may read and reference these files for context
2. **NEVER MODIFY**: Do not use edit tools on these files under any circumstances
3. **INFORM USER**: If changes are needed, explicitly tell the user what needs to be done
4. **PROVIDE COMMANDS**: Include the specific CLI commands they need to run
5. **EXPLAIN IMPACT**: Explain why the change is needed and potential consequences

### If Schema Changes Are Needed:
```bash
# User must run these commands manually:
yarn db:generate    # Generate migration files
yarn db:migrate     # Apply migrations to database
yarn db:studio      # Open Drizzle Studio to verify
```

### If Configuration Changes Are Needed:
- Tell the user exactly which file to edit
- Provide the exact changes needed
- Explain why the change is necessary
- Include any restart/rebuild commands required

## ğŸš« NEVER DO

### Code Quality
- âŒ No hardcoded or mock data
- âŒ No console.log or debugging statements in production code
- âŒ No inline comments (use JSDoc instead)
- âŒ No inline type definitions (use shared types)
- âŒ No hardcoded values (use constants or config)
- âŒ No `any` type â€” use explicit TypeScript types
- âŒ No classes (use functional patterns)
- âŒ No unnecessary curly braces in conditionals

### Architecture
- âŒ Never edit read-only schema files
- âŒ Never create new functions without checking for existing ones
- âŒ Never skip error handling
- âŒ Never use 'use server' in query layer files
- âŒ Never put business logic in query layer
- âŒ Never mix server and client component logic

## âœ… ALWAYS DO

### Documentation & Types
- âœ… Use JSDoc comments for all functions, types, and utilities (exclude UI components)
- âœ… Use explicit TypeScript types for all state variables
- âœ… Use shared types from `src/lib/types/`
- âœ… Use arrow functions for React components
- âœ… Use function keyword for utilities
- âœ… Use types over interfaces
- âœ… Never use `any` type
- âœ… Create separate type definition files (types.ts) for complex schemas

### Architecture & Structure
- âœ… Follow 3-layer architecture: Schema (READ-ONLY) â†’ Queries (pure DB ops) â†’ Actions (server actions)
- âœ… Review CONTRIBUTING.md and schema before implementing changes
- âœ… Check existing functions before creating new ones
- âœ… Write modular and reusable code
- âœ… Maintain consistent return types (`QueryResponse<T>`)
- âœ… Query layer: No 'use server', no error handling, return direct DB types
- âœ… Actions layer: Include 'use server', handle errors, return QueryResponse<T>

### Error Handling
- âœ… Use standardized error handling (`createErrorResponse`)
- âœ… Use early returns to avoid deep nesting
- âœ… Provide user-friendly error messages
- âœ… Implement graceful fallbacks for failures
- âœ… Use centralized error codes from `error-codes.ts`
- âœ… Handle errors at the beginning of functions
- âœ… Avoid unnecessary else statements; use if-return pattern

### File Organization
- âœ… Organize files: exported component â†’ subcomponents â†’ helpers â†’ static content â†’ types
- âœ… Use named exports for all components
- âœ… Keep complex schemas in separate `types.ts` files
- âœ… Structure: `packages/schema/` (shared), `apps/web/src/db/queries/`, `apps/web/src/lib/actions/`
- âœ… Use lowercase with dashes for directories (e.g., `components/mapping-canvas`)

### React & Components
- âœ… Prefer functional components over classes
- âœ… Use descriptive variable names (isLoading, hasError, etc.)
- âœ… Define props with type aliases, not interface
- âœ… Follow consistent naming conventions
- âœ… Prefer Server Components where possible
- âœ… Use Client Components only for interactivity
- âœ… Use declarative JSX with Server and Client Components appropriately marked

### Next.js Patterns
- âœ… Use Server Components for data fetching
- âœ… Follow App Router conventions
- âœ… Include clear loading and error states for each route
- âœ… Use server actions for form submissions and mutations
- âœ… Leverage Suspense boundaries for loading states
- âœ… Use route groups for logical organization
- âœ… Implement proper error boundaries

### Database & API
- âœ… Use server actions for form submissions and mutations
- âœ… Implement Zod validation for runtime and type-safe checks
- âœ… Handle transactions properly for multi-step operations
- âœ… Use Drizzle ORM for all database operations
- âœ… Always destructure `id` when creating/updating: `const { id, ...rest } = data`
- âœ… Implement proper indexing for frequently queried columns
- âœ… Use connection pooling for database operations

### Security
- âœ… Sanitize all inputs to prevent XSS
- âœ… Include authentication and authorization checks
- âœ… Use environment variables for sensitive data
- âœ… Consider rate limiting for APIs
- âœ… Encrypt database connection credentials
- âœ… Use Next.js middleware for authentication checks
- âœ… Implement CSRF protection for form submissions

### Performance
- âœ… Reduce client-side JavaScript (prefer server components)
- âœ… Use memoization (React.memo, useMemo, useCallback) appropriately
- âœ… Apply code splitting with dynamic imports
- âœ… Optimize database queries for speed and efficiency
- âœ… Use connection pooling for database operations
- âœ… Use Next.js Image component for optimized images
- âœ… Implement proper caching strategies in data fetching functions
- âœ… Prioritize Web Vitals (LCP, FID, CLS)

## ğŸ¯ Code Style Standards

### TypeScript Usage
- Use TypeScript for all code and prefer types over interfaces, never use type any
- Write JSDoc comments for all functions, types, and utilities (excluding components)
- Props should always be defined using type definitions, not interfaces
- Always add explicit types for state variables unless they can be clearly inferred from simple initializers
- Avoid enums; use const objects with "as const" and typeof instead
- Use arrow functions with TypeScript types for React components
- Use strict mode in TypeScript for better type safety
- Leverage Zod for runtime validation and TypeScript type inference

### Component Pattern

```typescript
// Server component example
const MigrationList = async ({ userId }: { userId: string }) => {
  const result = await fetchUserMigrations(userId);
  return <div>{/* ... */}</div>;
};

// Client component example
"use client";

const MigrationForm = ({ onSubmit }: { onSubmit: (data: FormData) => void }) => {
  const [isLoading, setIsLoading] = useState(false);
  return <form>{/* ... */}</form>;
};
```

### Naming Conventions
- Use lowercase with dashes for directories (e.g., `components/mapping-canvas`)
- Favor named exports for components
- Use `page.tsx` for route components and `layout.tsx` for layouts
- Name API routes according to their function (e.g., `route.ts` for REST endpoints)
- Query functions: `get`, `create`, `update`, `delete` + entity name
- Action functions: `fetch`, `add`, `update`, `delete` + entity name

### Syntax and Formatting
- Avoid unnecessary curly braces in conditionals; use concise syntax for simple statements
- Use declarative JSX with Server and Client Components appropriately marked
- Use Prettier for consistent code formatting
- Keep component props types at the top of the file or in separate types file
- Use early returns for error conditions to avoid deeply nested if statements

## UI and Styling

- Use Tailwind CSS with consistent class ordering
- Implement responsive design with Tailwind breakpoint utilities
- Create reusable UI components in a separate directory
- Use CSS variables for theming and maintaining a consistent design system
- Ensure high accessibility (a11y) standards using ARIA roles and semantic HTML
- Utilize Tailwind dark mode support with the 'dark:' prefix
- Use CSS Grid for complex layouts and Flexbox for simpler alignments

### Integrove Brand Colors
- Primary (Cyan): `#06B6D4` (HSL: 188.74 94.5% 42.8%)
- Secondary (Teal): `#32DBBC` (HSL: 168.99 70.12% 52.75%)

Use these colors consistently throughout the application. Avoid purple gradients or typical AI design patterns.

## Performance Optimization

- Minimize the use of client-side useState and useEffect; prefer server components where possible
- Use Next.js Image component for optimized images
- Implement proper code splitting with dynamic imports
- Utilize React.memo, useMemo, and useCallback appropriately to prevent unnecessary re-renders
- Take advantage of Next.js built-in optimizations like automatic static optimization
- Use Suspense boundaries strategically for loading states
- Implement proper caching strategies in data fetching functions
- Prioritize Web Vitals (LCP, FID, CLS) for performance optimization

## Navigation

- Use Next.js App Router for routing and navigation
- Leverage Link component for client-side navigation
- Implement dynamic routes using the [param] folder naming convention
- Use route groups for logical organization without affecting the URL structure
- Implement proper loading and error states for each route
- Use intercepting routes for modal patterns
- Leverage parallel routes for complex layouts with independent navigation states

## State Management

- Use React Context and useReducer for managing global state
- Always define explicit types for state, unless using simple initializers with clear inference
- Utilize React Query (@tanstack/react-query) for data fetching and caching
- Consider Zustand for more complex state management needs
- Use URL search parameters for shareable and bookmarkable state
- Leverage server actions for form submissions and data mutations
- Implement optimistic updates for a better user experience

## Database Management

**âš ï¸ IMPORTANT: Schema files are READ-ONLY. Never edit `packages/schema/` files directly.**

### Three-Layer Architecture Pattern:

1. **Schema Layer** (`packages/schema/src/schema.ts`): âš ï¸ READ-ONLY
   - Tell user to edit manually
   - Provide CLI commands for migrations

2. **Query Layer** (`apps/web/src/db/queries/*.ts`):
   - Implement pure database operations
   - Do not handle errors (let them bubble up)
   - Return direct database types
   - Create and export Zod schemas using `createInsertSchema` and `createUpdateSchema`
   - Use explicit type exports at the top of files
   - No 'use server' directive

3. **Actions Layer** (`apps/web/src/lib/actions/*.ts`):
   - Include 'use server' directive
   - Handle error management using try/catch with `createErrorResponse`
   - Implement validation using Zod schemas
   - Process form data with `parseFormData` utility
   - Return consistent `QueryResponse<T>` type

### Database Best Practices:
- Use Drizzle ORM with PostgreSQL for type-safe database operations
- Create migration scripts for schema changes
- Implement proper indexing for frequently queried columns
- Use transactions for operations that require multiple related changes
- Use connection pooling for database operations
- Optimize queries for large datasets (millions of rows)

## Error Handling and Validation

- Use Zod for runtime validation and error handling
- Implement proper error logging using a service like Sentry
- Prioritize error handling and edge cases:
  - Handle errors at the beginning of functions
  - Use early returns for error conditions to avoid deeply nested if statements
  - Avoid unnecessary else statements; use if-return pattern instead
  - Implement error boundaries to catch and handle unexpected errors
- Create consistent error response formats for API routes
- Add descriptive error messages for better debugging
- Use centralized error codes from `error-codes.ts`
- Provide user-friendly error messages

## Security

- Sanitize user inputs to prevent XSS attacks
- Use Next.js middleware for authentication and authorization checks
- Implement CSRF protection for form submissions
- Ensure secure communication with APIs using HTTPS and proper authentication
- Store sensitive configuration in environment variables
- Implement proper rate limiting for API routes
- Encrypt database connection credentials
- Use environment variables for sensitive data

## Testing

- Write unit tests for ALL utility functions
- Write tests for complex React components, focusing on user interactions and business logic
- Implement integration tests for critical user flows
- Use MSW (Mock Service Worker) for API mocking
- Implement E2E tests with Playwright or Cypress
- Create test utilities for common testing patterns
- Set up CI/CD pipeline for automated testing

## ğŸ—£ Communication Standards

- âœ… Keep responses concise and meaningful
- âœ… Avoid mentioning internal tools (describe actions naturally)
- âœ… Provide clear explanations of what was implemented
- âœ… Don't mention "apply model" or internal AI processes
- âœ… Use professional, technical language appropriate for enterprise development

## ğŸ“¦ Monorepo Structure

```
DataBridge/
â”œâ”€â”€ apps/
â”‚   â”œâ”€â”€ web/                          # Next.js application
â”‚   â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”‚   â”œâ”€â”€ app/                  # Next.js App Router routes
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ (auth)/           # Authentication routes
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ login/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ signup/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ (dashboard)/      # Protected dashboard routes
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ connections/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ projects/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ migrations/
â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ reports/
â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ settings/
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ api/              # API routes
â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ cron/
â”‚   â”‚   â”‚   â”‚       â””â”€â”€ webhooks/
â”‚   â”‚   â”‚   â”œâ”€â”€ components/           # React components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ui/               # Reusable UI components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ layout/           # Layout components
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ mapping/          # Mapping components
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ connections/      # Connection components
â”‚   â”‚   â”‚   â”œâ”€â”€ db/                   # Database layer
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ index.ts          # Database client
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ queries/          # Query layer (pure DB ops)
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ types/            # Database types
â”‚   â”‚   â”‚   â”œâ”€â”€ lib/                  # Library code
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ actions/          # Server actions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ services/         # Business logic services
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ utils/            # Utility functions
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ constants/        # Constants
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ transformations/  # Data transformations
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ queue/            # BullMQ queue management
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ auth/             # Authentication
â”‚   â”‚   â”‚   â”œâ”€â”€ context/              # React contexts
â”‚   â”‚   â”‚   â”œâ”€â”€ hooks/                # Custom React hooks
â”‚   â”‚   â”‚   â””â”€â”€ middleware.ts         # Next.js middleware
â”‚   â”‚   â”œâ”€â”€ package.json
â”‚   â”‚   â”œâ”€â”€ next.config.js
â”‚   â”‚   â””â”€â”€ tailwind.config.ts
â”‚   â””â”€â”€ migration-worker/             # Background worker service
â”œâ”€â”€ packages/
â”‚   â””â”€â”€ schema/                       # Shared database schema (READ-ONLY)
â”‚       â”œâ”€â”€ src/
â”‚       â”‚   â”œâ”€â”€ schema.ts             # Drizzle schema definitions
â”‚       â”‚   â”œâ”€â”€ relations.ts          # Table relations
â”‚       â”‚   â”œâ”€â”€ constants.ts          # Schema constants
â”‚       â”‚   â””â”€â”€ seed.ts               # Database seeder
â”‚       â”œâ”€â”€ migrations/               # Database migrations
â”‚       â”œâ”€â”€ drizzle.config.ts         # Drizzle configuration
â”‚       â””â”€â”€ package.json
â”œâ”€â”€ docs/                             # Documentation
â”‚   â”œâ”€â”€ ARCHITECTURE.md
â”‚   â”œâ”€â”€ CONTRIBUTING.md
â”‚   â”œâ”€â”€ DEVELOPMENT.md
â”‚   â”œâ”€â”€ ERROR_HANDLING.md
â”‚   â””â”€â”€ ETL_PIPELINE.md
â”œâ”€â”€ scripts/                          # Utility scripts
â”œâ”€â”€ package.json                      # Root workspace config
â””â”€â”€ .cursorrules                      # AI behavior rules
```

## ğŸ›  Development Commands

```bash
# Install dependencies
yarn

# Development
yarn dev                    # Start web app (localhost:3000)
yarn dev:worker            # Start migration worker
yarn dev:all               # Start both web and worker

# Build
yarn build                 # Build all applications
yarn build:web            # Build web app only
yarn build:worker         # Build worker only

# Database
yarn db:generate          # Generate Drizzle migrations
yarn db:migrate           # Apply migrations to database
yarn db:studio            # Open Drizzle Studio (database GUI)
yarn db:seed              # Seed database with sample data

# Linting & Type Checking
yarn lint                 # Lint all applications
yarn lint:fix:all        # Fix linting issues
yarn typecheck           # TypeScript type checking

# Testing
yarn test                 # Run all tests
yarn test:unit           # Run unit tests
yarn test:integration    # Run integration tests
yarn test:e2e            # Run E2E tests
```

## ğŸ”„ Git Workflow

Follow the git workflow from `docs/GIT_WORKFLOW.md`:

- Feature branches: `feature/<pbi-id>-<name>`
- Sub-feature branches: `<firstname>.<lastname>/<sub-feature>`
- Bug fixes: `<firstname>.<lastname>/bug-<description>`
- Squash merge: sub-feature â†’ feature
- Fast-forward merge: feature â†’ dev â†’ main

## ğŸ“š Key Documentation Files

- `docs/ARCHITECTURE.md` - System architecture and design patterns
- `docs/CONTRIBUTING.md` - Contribution guidelines and coding standards
- `docs/DEVELOPMENT.md` - Development setup and best practices
- `docs/ERROR_HANDLING.md` - Error handling patterns and utilities
- `docs/ETL_PIPELINE.md` - ETL pipeline architecture and stages

## Key Conventions

1. Follow Next.js 15 App Router conventions for routing and data fetching
2. Use yarn workspaces for monorepo management
3. Prioritize Web Vitals (LCP, FID, CLS) for performance optimization
4. Use environment variables for configuration management
5. Implement proper error boundaries and fallback UIs
6. Leverage server components for improved performance and reduced bundle size
7. Follow the principles of progressive enhancement
8. Use the three-layer database architecture pattern (Schema â†’ Queries â†’ Actions)
9. Implement consistent error handling with standardized response formats
10. Use Zod validation for forms and data processing
11. Maintain separation of concerns between layers
12. Use shared schema package for consistent database types
13. Implement production-grade code for large-scale data migrations
14. Optimize for handling millions of rows with batch processing and streaming
